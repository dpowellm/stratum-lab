==============================================================================
MODULE SUMMARY -- stratum-lab code inventory
==============================================================================

------------------------------------------------------------------------------
Module: scripts\aggregate_results.py
Lines:  896
Doc:    Post-scan aggregator -- reads ALL results/*/ directories and produces scan_report.json.
Deps:   __future__, argparse, collections, datetime, json, pathlib, sys
  Functions (2):
    aggregate() (line 399): Aggregate all per-repo results into a scan_report.json structure.
    main() (line 845): (no docstring)

------------------------------------------------------------------------------
Module: scripts\build_behavioral_records.py
Lines:  1185
Doc:    Convert raw stratum_events.jsonl files from multiple runs into
Deps:   __future__, argparse, glob, json, logging, os, output_classifier, pathlib, sys
  Functions (24):
    build_behavioral_record() (line 79): Build a v6 behavioral record from multiple run event files.
    build_execution_metadata() (line 156): Aggregate run metadata into a single execution_metadata block.
    extract_all_nodes() (line 189): Extract all unique node IDs observed across all runs.
    infer_structural_graph() (line 206): Build a structural graph from runtime events.
    classify_node_type() (line 246): Classify node into stratum-graph categories.
    extract_runtime_edges() (line 270): Extract edges that actually fired from runtime events.
    compute_edge_validation() (line 346): Compare structural edges against runtime activation.
    edge_matches_runtime() (line 388): Check if a structural edge was traversed in a set of runtime edges.
    infer_dead_edge_reason() (line 402): Heuristic reasons why a structural edge was never activated.
    detect_emergent_edges() (line 440): Find runtime edges that do NOT exist in the structural graph.
    classify_node_activation() (line 476): Classify nodes as always_active, conditional, or never_active.
    trace_error_propagation() (line 521): Trace how errors propagate through the agent topology.
    bfs_from_node() (line 565): BFS traversal from a node in the structural graph.
    trace_actual_error_path() (line 595): Trace the actual observed error propagation path.
    count_downstream_errors() (line 661): Count error events that occur after *error_event*.
    count_downstream_failures() (line 674): Count task-end events with a failed status after *error_event*.
    is_error_swallowed() (line 689): Check if an error was swallowed (no downstream error propagation).
    classify_failure_modes() (line 723): Detect STRAT- failure modes from behavioral signals.
    detect_signals() (line 765): Detect specific behavioral signals across runs.
    has_downstream_impact() (line 843): Check if a detected signal has downstream impact.
    compute_monitoring_baselines() (line 958): Compute per-metric baselines across runs.
    compute_metric() (line 988): Compute an individual metric for a single run.
    enrich_with_output_classification() (line 1059): Enrich events that have output_preview with output classification.
    main() (line 1084): (no docstring)

------------------------------------------------------------------------------
Module: scripts\check_pilot_quality.py
Lines:  370
Doc:    Pilot quality gate -- categorize pilot runs and check thresholds before full scan.
Deps:   __future__, argparse, collections, json, pathlib, sys
  Functions (5):
    categorize_run() (line 129): Categorize a single run into one of the pilot categories.
    categorize_all_runs() (line 225): Categorize every run subdirectory and return category counts.
    print_pilot_report() (line 245): Print a formatted pilot quality report.
    check_pilot_quality() (line 283): Check if pilot run meets quality thresholds.
    main() (line 333): (no docstring)

------------------------------------------------------------------------------
Module: scripts\output_classifier.py
Lines:  152
Doc:    Heuristic output classifier for AI agent outputs.
Deps:   __future__, argparse, json, pathlib, re, sys
  Functions (1):
    classify_output() (line 18): Returns {"primary": "factual", "confidence": 0.7, "signals": [...]}

------------------------------------------------------------------------------
Module: scripts\select_repos.py
Lines:  584
Doc:    Select and rank repos for behavioral scanning.
Deps:   __future__, argparse, datetime, hashlib, json, os, pathlib, requests, sys, time, typing
  Functions (9):
    deduplicate() (line 120): Remove hash-based duplicates, keeping the highest-scored entry.
    is_xcomp() (line 139): Check if repo has cross-component interactions.
    compute_topology_hash() (line 154): Hash based on agent_count, framework, tool_count, etc.
    rerank_for_topology_diversity() (line 167): Rerank selection to maximize unique topology patterns.
    score_repo() (line 200): (no docstring)
    load_scan_results() (line 353): Load scan_results.jsonl entries, score them, and return (score, url, raw_data) tuples.
    load_plain_urls() (line 384): (no docstring)
    discover_repos() (line 464): (no docstring)
    main() (line 494): (no docstring)

------------------------------------------------------------------------------
Module: scripts\smoke_test.py
Lines:  433
Doc:    Smoke test: run 3-5 known-good repos through the full pipeline with real Docker execution.
Deps:   __future__, argparse, json, os, pathlib, shutil, subprocess, sys, tempfile, time, urllib
  Functions (11):
    check_docker() (line 53): Check that Docker daemon is running.
    check_vllm() (line 73): Check that vLLM endpoint is reachable and responding.
    check_runner_image() (line 103): Check that the stratum-lab-runner Docker image exists.
    check_fixtures() (line 123): Check that all smoke test fixture files exist.
    run_preflight() (line 135): Run all preflight checks. Returns True if all pass.
    run_pipeline() (line 163): Run stratum-lab pipeline on a fixture directory.
    count_events() (line 211): Count total events across all JSONL files in the raw_events directory.
    validate_output() (line 230): Run validate_scan.py on the output directory.
    check_behavioral_records() (line 256): Check if behavioral record files were produced.
    run_smoke_test() (line 282): Run the full smoke test suite.
    main() (line 394): (no docstring)

------------------------------------------------------------------------------
Module: scripts\synthetic_harness.py
Lines:  1316
Doc:    Tier 2 Synthetic Harness -- fallback when native execution fails.
Deps:   __future__, os, pathlib, re, subprocess, sys, textwrap, typing
  Functions (13):
    detect_frameworks() (line 99): Detect which frameworks a repo uses and count pattern matches.
    read_all_py_files() (line 118): Concatenate all Python source files (excluding vendored dirs) into
    find_agents() (line 135): Return a list of agent role names found in *source_code* via
    select_variant() (line 149): Choose a topology variant based on what was found in repo source.
    extract_crewai_agents() (line 211): Extract CrewAI ``Agent()`` definitions from source files.
    extract_crewai_tasks() (line 239): Extract CrewAI ``Task()`` definitions from source files.
    extract_langgraph_nodes() (line 262): Extract LangGraph node names from ``add_node()`` calls.
    extract_autogen_agents() (line 277): Extract AutoGen agent definitions.
    generate_crewai_script() (line 331): Generate a self-contained CrewAI script with topology variety.
    generate_langgraph_script() (line 679): Generate a self-contained LangGraph script with topology variety.
    generate_autogen_script() (line 909): Generate a self-contained AutoGen script with topology variety.
    generate_openai_script() (line 1118): Generate a simple OpenAI-compatible script (3 varied calls).
    main() (line 1155): Entry point.  Returns 0 on success, 1 on failure.

------------------------------------------------------------------------------
Module: scripts\validate_scan.py
Lines:  332
Doc:    Post-scan validation script.
Deps:   __future__, argparse, json, pathlib, stratum_lab, sys
  Functions (2):
    validate_scan() (line 45): Run all validation checks against *scan_dir*.
    main() (line 312): (no docstring)

------------------------------------------------------------------------------
Module: scripts\validate_scan_output.py
Lines:  221
Doc:    Post-scan validation script.
Deps:   __future__, argparse, json, pathlib, sys
  Functions (4):
    validate() (line 20): Validate scan output artifacts.
    main() (line 209): (no docstring)
    check() (line 30): (no docstring)
    warn() (line 43): (no docstring)

------------------------------------------------------------------------------
Module: scripts\validate_smoke.py
Lines:  770
Doc:    Validate per-repo scan output directories with enriched output.
Deps:   __future__, argparse, collections, json, pathlib, sys
  Functions (3):
    check_v6_compatibility() (line 129): Check whether collected events are sufficient for v6 behavioral record.
    validate_repo() (line 206): Validate a single repo output directory.
    main() (line 587): (no docstring)

------------------------------------------------------------------------------
Module: stratum_lab\__init__.py
Lines:  3
Doc:    Stratum Lab — Behavioral scan infrastructure for AI agent repos.

------------------------------------------------------------------------------
Module: stratum_lab\cli.py
Lines:  539
Doc:    Main CLI entry point for stratum-lab pipeline.
Deps:   click, collections, csv, json, pathlib, rich, stratum_lab
  Functions (9):
    main() (line 10): Stratum Lab — Behavioral scan infrastructure for AI agent repos.
    select() (line 21): Phase 1: Select repos for graph discovery coverage.
    execute() (line 44): Phase 2: Execute selected repos in sandboxed containers.
    collect() (line 58): Phase 3: Parse raw event files into structured run records.
    overlay() (line 72): Phase 4: Merge behavioral data onto structural graphs.
    knowledge() (line 85): Build cross-repo pattern knowledge base from enriched graphs.
    query() (line 102): Query the behavioral dataset with a structural graph to predict risks.
    pipeline() (line 182): Run the full stratum-lab pipeline.
    validate_ids() (line 468): Validate node ID compatibility between structural scan and patcher.
  Click options (33):
    -o/--output: Output selection file path.
    -n/--target: Target number of repos to select.
    --min-runnability: Minimum runnability score filter.
    --max-per-archetype: Max repos per archetype.
    -o/--output-dir: Output directory for event files.
    --vllm-url: vLLM OpenAI-compatible endpoint URL.
    --concurrent: Number of concurrent containers.
    --max-concurrent: Max concurrent container executions.
    --timeout: Per-execution timeout in seconds.
    --runs: 
    --dry-run: Print what would be executed without running.
    --resume: Resume from scan_checkpoint.json, skipping completed repos.
    -o/--output: Output run records file.
    -o/--output-dir: Output directory for enriched graph files.
    -o/--output-dir: Output directory for knowledge base files.
    --knowledge-base/-kb: click
    --output-format: click
    --output/-o: click
    --target: Target number of repos to select.
    --vllm-url: vLLM endpoint URL.
    --concurrent: Concurrent containers.
    --max-concurrent: Max concurrent container executions.
    --timeout: Execution timeout seconds.
    --pilot-size: Number of repos in pilot batch.
    --max-instrumentation-failure-rate: Abort if instrumentation failure rate exceeds this in pilot.
    --max-model-failure-rate: Abort if model failure rate exceeds this in pilot.
    --enterprise-outreach: Run enterprise classification + contact extraction + outreach queue generation.
    --probe-batch-size: int
    --probe-timeout: Probe timeout in seconds.
    --output-dir: click
    --resume: Resume from scan_checkpoint.json, skipping completed repos.
    --graph-json: click
    --events-dir: click

------------------------------------------------------------------------------
Module: stratum_lab\collection\__init__.py
Lines:  1
Doc:    Phase 3: Data Collection — JSONL event parsing and run record construction.

------------------------------------------------------------------------------
Module: stratum_lab\collection\cli.py
Lines:  224
Doc:    CLI runner for Phase 3: Data Collection.
Deps:   __future__, collections, json, pathlib, rich, stratum_lab, time, typing
  Functions (1):
    run_collection() (line 106): Parse raw event files into structured run records.

------------------------------------------------------------------------------
Module: stratum_lab\collection\parser.py
Lines:  493
Doc:    JSONL event parser and run record builder.
Deps:   __future__, collections, json, logging, pathlib, typing
  Functions (4):
    validate_event() (line 48): Validate that an event dict has all required fields.
    parse_events_file() (line 70): Read a JSONL file line by line and return a list of EventRecord dicts.
    build_run_record() (line 144): Build a structured RunRecord from parsed events and optional metadata.
    aggregate_run_records() (line 353): Aggregate multiple run records for the same repo into a repo-level summary.

------------------------------------------------------------------------------
Module: stratum_lab\config.py
Lines:  152
Doc:    Global configuration constants for stratum-lab.
Deps:   pathlib
  Classes (1):
    class ExecutionStatus (line 36): (no docstring)

------------------------------------------------------------------------------
Module: stratum_lab\feedback\__init__.py
Lines:  1
Doc:    Feedback export — artifacts importable by the reliability scanner.

------------------------------------------------------------------------------
Module: stratum_lab\feedback\exporter.py
Lines:  362
Doc:    Feedback export module.
Deps:   __future__, json, pathlib, stratum_lab, typing
  Functions (1):
    export_feedback() (line 63): Export feedback artifacts from behavioral records.

------------------------------------------------------------------------------
Module: stratum_lab\harness\__init__.py
Lines:  1
Doc:    Phase 2: Execution Harness — sandboxed container execution of selected repos.

------------------------------------------------------------------------------
Module: stratum_lab\harness\cli.py
Lines:  187
Doc:    CLI runner for Phase 2: Execution Harness.
Deps:   __future__, collections, json, pathlib, rich, stratum_lab
  Functions (1):
    run_execution() (line 23): Entry point for Phase 2 execution.

------------------------------------------------------------------------------
Module: stratum_lab\harness\container.py
Lines:  422
Doc:    Docker container management for sandboxed repo execution.
Deps:   __future__, dataclasses, docker, io, os, pathlib, rich, shutil, stratum_lab, tarfile, tempfile, time, typing
  Classes (1):
    class RunResult (line 38): Result of a single container execution run.
  Functions (3):
    build_image() (line 57): Build the stratum-lab-runner Docker image.
    run_container() (line 111): Run a single repo execution inside a Docker container.
    collect_artifacts() (line 286): Copy event file and logs from a (still-existing) container.

------------------------------------------------------------------------------
Module: stratum_lab\harness\input_generator.py
Lines:  384
Doc:    Synthetic input generation for repo execution.
Deps:   __future__, hashlib, json, openai, pathlib, re, rich, stratum_lab, typing
  Functions (4):
    generate_inputs() (line 71): Use vLLM to generate *count* diverse synthetic test inputs.
    find_example_inputs() (line 152): Search a cloned repo for existing example inputs.
    plan_runs() (line 224): Plan the run schedule: 3 diverse inputs + 2 repeats of the first.
    input_hash() (line 270): Return a short hex hash of an input string for cache keying.

------------------------------------------------------------------------------
Module: stratum_lab\harness\orchestrator.py
Lines:  775
Doc:    Main orchestrator for Phase 2 execution.
Deps:   __future__, asyncio, concurrent, csv, datetime, json, logging, pathlib, rich, shutil, stratum_lab, threading, time, typing, uuid
  Classes (2):
    class LatencyTracker (line 40): Track rolling average inference latency for adaptive backpressure.
      .record() (line 48): Record a latency sample.
      .avg_last_window() (line 54): Return average latency over the last window_seconds.
    class Orchestrator (line 89): Schedules and executes container runs for all selected repos.
      .run() (line 150): Execute all selected repos and return collected results.
      .execute_repo() (line 259): Execute a single run for a repo.
      .execute_repo_with_probe() (line 336): Run a quick probe first. Only proceed to full runs if probe produces events.
      .resolve_entry_point() (line 397): Resolve the best entry point for a repo.
      .classify_status() (line 431): Determine execution status from exit code, events, and errors.
      .classify_status_detailed() (line 514): Classify execution outcome with detailed breakdown (Issue 23).
      .load_checkpoint() (line 696): Load completed repo IDs from checkpoint file (backward compat).
      .save_checkpoint() (line 700): Save a completed repo to the checkpoint file (backward compat).
      .is_repo_completed() (line 710): Check if a repo has already been completed.
  Functions (11):
    record() (line 48): Record a latency sample.
    avg_last_window() (line 54): Return average latency over the last window_seconds.
    run() (line 150): Execute all selected repos and return collected results.
    execute_repo() (line 259): Execute a single run for a repo.
    execute_repo_with_probe() (line 336): Run a quick probe first. Only proceed to full runs if probe produces events.
    resolve_entry_point() (line 397): Resolve the best entry point for a repo.
    classify_status() (line 431): Determine execution status from exit code, events, and errors.
    classify_status_detailed() (line 514): Classify execution outcome with detailed breakdown (Issue 23).
    load_checkpoint() (line 696): Load completed repo IDs from checkpoint file (backward compat).
    save_checkpoint() (line 700): Save a completed repo to the checkpoint file (backward compat).
    is_repo_completed() (line 710): Check if a repo has already been completed.

------------------------------------------------------------------------------
Module: stratum_lab\harness\run_scheduler.py
Lines:  97
Doc:    Adaptive run scheduling.
Deps:   __future__, typing
  Functions (3):
    compute_run_count() (line 22): Determine how many runs this repo needs.
    plan_adaptive_runs() (line 53): Plan the run schedule for a repo.
    compute_budget() (line 84): Compute total run budget for a set of repos.

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\__init__.py
Lines:  1
Doc:    Knowledge Base — cross-repo pattern extraction and taxonomy analysis.

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\cli.py
Lines:  342
Doc:    CLI runner for the Knowledge Base build phase.
Deps:   __future__, json, pathlib, rich, stratum_lab, time, typing
  Functions (1):
    run_knowledge_build() (line 194): Build the cross-repo pattern knowledge base.

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\fragility.py
Lines:  238
Doc:    Fragility map builder.
Deps:   __future__, collections, numpy, typing
  Functions (2):
    compute_sensitivity_score() (line 83): Compute a 0-1 sensitivity score for how model-sensitive a node is.
    build_fragility_map() (line 134): Build a fragility map identifying model-sensitive structural positions.

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\interactions.py
Lines:  107
Doc:    Cross-pattern interaction analysis.
Deps:   collections, itertools, typing
  Functions (2):
    compute_interaction_matrix() (line 19): Compute pairwise interaction effects between preconditions.
    fail_rate() (line 62): (no docstring)

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\patterns.py
Lines:  826
Doc:    Pattern knowledge base builder.
Deps:   __future__, collections, hashlib, json, numpy, scipy, typing
  Functions (5):
    build_pattern_knowledge_base() (line 37): Build the pattern knowledge base from all enriched graphs.
    extract_structural_motifs() (line 129): Identify structural patterns (motifs) in an enriched graph.
    compute_behavioral_distribution() (line 472): Compute behavioral distribution for a given motif across repos.
    detect_novel_patterns() (line 595): Cluster behavioral data to find failure modes not in the known taxonomy.
    compare_frameworks() (line 702): Compare behavioral outcomes for the same structural pattern across frameworks.

------------------------------------------------------------------------------
Module: stratum_lab\knowledge\taxonomy.py
Lines:  514
Doc:    Taxonomy probability computation.
Deps:   __future__, collections, numpy, scipy, typing
  Functions (4):
    count_manifestations() (line 65): Count raw manifestations without statistical claims.
    compute_manifestation_probabilities() (line 112): Compute the probability that each taxonomy precondition manifests as failure.
    compute_structural_metric_correlations() (line 278): Correlate structural metrics with runtime failure rates.
    compute_severity_score() (line 436): 0-100 severity score combining error volume, cascade depth, and blast radius.

------------------------------------------------------------------------------
Module: stratum_lab\models.py
Lines:  163
Doc:    Shared data models for stratum-lab pipeline.
Deps:   __future__, dataclasses, enum, typing
  Classes (12):
    class NodeType (line 10): (no docstring)
    class EdgeType (line 19): (no docstring)
    class RepoSelection (line 34): A single repo selected for behavioral scanning.
    class SelectionSummary (line 52): Aggregate summary of the selection.
    class RunMetadata (line 63): Metadata for a single execution run.
    class EventRecord (line 80): A single event from the JSONL event stream.
    class NodeBehavior (line 97): Behavioral overlay data for a single node.
    class EdgeBehavior (line 110): Behavioral overlay data for a single edge.
    class EmergentEdge (line 122): A runtime-only edge not present in the structural graph.
    class DeadEdge (line 134): A structural edge that never activated at runtime.
    class Pattern (line 143): A structural pattern with behavioral statistics.
    class EnrichedGraph (line 155): A structural graph enriched with behavioral data.

------------------------------------------------------------------------------
Module: stratum_lab\node_ids.py
Lines:  108
Doc:    Node ID generation matching stratum-cli's structural graph IDs.
Deps:   __future__, re
  Functions (7):
    normalize_name() (line 22): Convert a name to lowercase underscore form matching stratum-cli.
    structural_agent_id() (line 31): Generate the structural graph agent node ID.
    structural_capability_id() (line 36): Generate the structural graph capability node ID.
    structural_data_store_id() (line 41): Generate the structural graph data store node ID.
    structural_external_id() (line 47): Generate the structural graph external service node ID.
    runtime_node_id() (line 53): Generate a runtime node ID from patcher context.
    match_runtime_to_structural() (line 61): Attempt to match a runtime node ID to a structural graph node.

------------------------------------------------------------------------------
Module: stratum_lab\output\__init__.py
Lines:  1
Doc:    Output modules — behavioral record assembly.

------------------------------------------------------------------------------
Module: stratum_lab\output\behavioral_record.py
Lines:  121
Doc:    Per-repo behavioral record assembly.
Deps:   __future__, typing
  Functions (2):
    build_behavioral_record() (line 46): Assemble the per-repo behavioral record for stratum-graph.
    validate_behavioral_record() (line 74): Validate a behavioral record has all required fields.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\__init__.py
Lines:  1
Doc:    Enterprise identification and outreach infrastructure.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\contact_extractor.py
Lines:  319
Doc:    Contact extraction from multiple sources.
Deps:   __future__, logging, re, typing
  Functions (1):
    extract_contacts() (line 268): Extract and deduplicate contacts from all sources.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\enterprise_classifier.py
Lines:  253
Doc:    Enterprise classifier with a 0-100 scoring rubric.
Deps:   __future__, datetime, logging, re, typing
  Functions (2):
    classify_repo() (line 191): Classify a single repository and return scoring breakdown.
    classify_batch() (line 229): Classify a list of enriched repo metadata dicts.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\github_enricher.py
Lines:  222
Doc:    GitHub API enrichment for repository metadata collection.
Deps:   __future__, base64, json, logging, os, pathlib, time, typing, urllib
  Classes (1):
    class GitHubEnricher (line 24): Enrich repository metadata via the GitHub REST API.
      .enrich_repo() (line 88): Collect all available metadata for *owner/repo*.
      .enrich_batch() (line 173): Enrich a list of ``owner/repo`` strings.
  Functions (2):
    enrich_repo() (line 88): Collect all available metadata for *owner/repo*.
    enrich_batch() (line 173): Enrich a list of ``owner/repo`` strings.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\metadata_schema.py
Lines:  92
Doc:    Metadata schema for enterprise classification and contact extraction.
Deps:   __future__, typing
  Functions (1):
    validate_metadata() (line 49): Check what metadata fields are present and report coverage.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\queue.py
Lines:  243
Doc:    Outreach queue builder.
Deps:   __future__, csv, datetime, json, logging, pathlib, typing
  Functions (2):
    build_outreach_queue() (line 73): Build a prioritised outreach queue.
    save_queue() (line 166): Save the outreach queue as JSON and CSV.

------------------------------------------------------------------------------
Module: stratum_lab\outreach\teaser_report.py
Lines:  175
Doc:    Teaser report generator.
Deps:   __future__, logging, typing
  Functions (1):
    generate_teaser() (line 97): Generate a teaser from a full Stratum risk report.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\__init__.py
Lines:  1
Doc:    Phase 4: Graph Overlay — behavioral enrichment of structural graphs.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\cli.py
Lines:  354
Doc:    CLI runner for Phase 4: Graph Overlay.
Deps:   __future__, collections, json, pathlib, rich, stratum_lab, time, typing
  Functions (1):
    run_overlay() (line 192): Merge behavioral data onto structural graphs.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\edges.py
Lines:  592
Doc:    Emergent and dead edge detection.
Deps:   __future__, collections, stratum_lab, typing
  Functions (4):
    detect_emergent_edges() (line 20): Find runtime interactions with no corresponding structural edge.
    detect_emergent_edges_v2() (line 106): Detect runtime interactions with no structural counterpart.
    detect_dead_edges() (line 349): Find structural edges that were never traversed at runtime.
    classify_edge_significance() (line 436): Classify the significance of an emergent edge.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\enricher.py
Lines:  1880
Doc:    Graph enrichment engine.
Deps:   __future__, collections, math, numpy, stratum_lab, typing
  Functions (5):
    compute_node_behavioral_overlay() (line 55): Compute behavioral statistics for one structural node.
    compute_edge_behavioral_overlay() (line 381): Compute behavioral statistics for one structural edge.
    compute_edge_validation() (line 490): Compute edge validation matrix.
    compute_node_activation() (line 707): Classify nodes by activation pattern.
    enrich_graph() (line 816): Enrich a structural graph with behavioral data from runtime events.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\error_propagation.py
Lines:  285
Doc:    Error propagation path reconstruction.
Deps:   __future__, collections, typing
  Functions (1):
    trace_error_propagation() (line 17): Trace error propagation paths from runtime events.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\failure_modes.py
Lines:  216
Doc:    Failure mode classification against finding taxonomy.
Deps:   __future__, collections, stratum_lab, typing
  Functions (1):
    classify_failure_modes() (line 54): Classify failure modes from runtime behavioral evidence.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\monitoring_baselines.py
Lines:  235
Doc:    Monitoring baseline extraction from behavioral observations.
Deps:   __future__, collections, math, stratum_lab, typing
  Functions (1):
    extract_monitoring_baselines() (line 55): Extract monitoring baselines from behavioral observations.

------------------------------------------------------------------------------
Module: stratum_lab\overlay\semantic_lineage.py
Lines:  178
Doc:    Reconstruct semantic data flow across the agent graph.
Deps:   collections, typing
  Functions (2):
    reconstruct_lineage() (line 14): Build the semantic lineage graph from events.
    depth() (line 140): (no docstring)

------------------------------------------------------------------------------
Module: stratum_lab\query\__init__.py
Lines:  1
Doc:    Product query layer — matches structural graphs against the behavioral dataset.

------------------------------------------------------------------------------
Module: stratum_lab\query\batch_report.py
Lines:  101
Doc:    Batch report generation for all repos in the dataset.
Deps:   collections, json, pathlib, stratum_lab, typing
  Functions (1):
    generate_batch_reports() (line 15): Generate risk reports for every enriched graph in the dataset.

------------------------------------------------------------------------------
Module: stratum_lab\query\fingerprint.py
Lines:  849
Doc:    Structural fingerprint computation for graph similarity matching.
Deps:   __future__, collections, hashlib, json, numpy, stratum_lab, typing
  Functions (3):
    compute_graph_fingerprint() (line 52): Compute a structural fingerprint from an enriched graph.
    normalize_feature_vector() (line 260): Normalize a feature vector to [0, 1] using stored min/max constants.
    compute_normalization_constants() (line 295): Compute per-feature min/max from a collection of fingerprints.

------------------------------------------------------------------------------
Module: stratum_lab\query\matcher.py
Lines:  710
Doc:    Pattern matcher — matches a customer's graph fingerprint against the behavioral dataset.
Deps:   __future__, dataclasses, json, numpy, pathlib, typing
  Classes (1):
    class Match (line 27): A single match result pairing a fingerprint to a known pattern.
  Functions (2):
    cosine_similarity() (line 42): Compute cosine similarity between two vectors.
    match_against_dataset() (line 505): Find the closest patterns in the knowledge base for a given fingerprint.

------------------------------------------------------------------------------
Module: stratum_lab\query\predictor.py
Lines:  905
Doc:    Risk predictor — produces risk predictions from matched patterns.
Deps:   __future__, dataclasses, json, pathlib, stratum_lab, typing
  Classes (2):
    class PredictedRisk (line 24): A single predicted risk tied to a taxonomy precondition.
    class RiskPrediction (line 41): Aggregate risk prediction for a structural graph.
  Functions (1):
    predict_risks() (line 700): Combine structural analysis with behavioral predictions.

------------------------------------------------------------------------------
Module: stratum_lab\query\report.py
Lines:  278
Doc:    Risk report generation.
Deps:   __future__, json, typing
  Functions (1):
    generate_risk_report() (line 13): Generate the customer-facing risk report.

------------------------------------------------------------------------------
Module: stratum_lab\selection\__init__.py
Lines:  1
Doc:    Phase 1: Repo Selection — scoring and selection of repos for behavioral scanning.

------------------------------------------------------------------------------
Module: stratum_lab\selection\cli.py
Lines:  204
Doc:    CLI runner for Phase 1: Repo Selection.
Deps:   __future__, json, pathlib, rich, stratum_lab, time, typing
  Functions (1):
    run_selection() (line 112): Load scan results, apply discovery optimizer, and write output JSON.

------------------------------------------------------------------------------
Module: stratum_lab\selection\discovery_optimizer.py
Lines:  295
Doc:    Graph discovery coverage optimizer.
Deps:   __future__, typing
  Functions (3):
    compute_discovery_value() (line 102): Compute the marginal graph discovery value of adding this repo.
    select_for_discovery() (line 174): Select repos to maximize graph discovery coverage.
    validate_coverage() (line 225): Validate the selected set meets coverage requirements.

------------------------------------------------------------------------------
Module: stratum_lab\selection\schema.py
Lines:  39
Doc:    Input schema for repo selection.
Deps:   __future__, typing
  Functions (1):
    validate_selection_input() (line 36): Validate a repo dict has the fields needed for selection.

------------------------------------------------------------------------------
Module: stratum_lab\selection\scorer.py
Lines:  220
Doc:    Scoring functions for repo selection.
Deps:   __future__, stratum_lab, typing
  Functions (6):
    compute_structural_value() (line 43): Return the structural value score (0-40) for a repo scan dict.
    compute_archetype_rarity() (line 85): Return the archetype rarity score (0-30).
    compute_runnability() (line 122): Return the runnability likelihood score (0-30).
    resolve_primary_framework() (line 155): Pick the primary framework label for a repo.
    estimate_complexity() (line 171): Return ``"low"``, ``"medium"``, or ``"high"`` based on agent count and edges.
    score_repo() (line 186): Score a single repo and return the full selection record dict.

------------------------------------------------------------------------------
Module: stratum_lab\selection\selector.py
Lines:  347
Doc:    Selection algorithm for Phase 1 repo selection.
Deps:   __future__, collections, stratum_lab, typing
  Functions (2):
    select_repos() (line 38): Apply the constrained greedy selection algorithm.
    score_and_select() (line 244): End-to-end: score raw structural scan dicts, then select.

------------------------------------------------------------------------------
Module: stratum_lab\triage\__init__.py
Lines:  1
Doc:    Phase 0: Pre-execution triage — static analysis of execution viability.

------------------------------------------------------------------------------
Module: stratum_lab\triage\probe.py
Lines:  194
Doc:    Probe execution — lightweight viability test.
Deps:   __future__, dataclasses, enum, typing
  Classes (2):
    class ProbeResult (line 20): (no docstring)
    class ProbeOutcome (line 30): (no docstring)
  Functions (2):
    run_probe() (line 41): Run a single probe execution against a repo.
    probe_batch() (line 160): Probe a batch of repos and return viability results.

------------------------------------------------------------------------------
Module: stratum_lab\triage\static_analyzer.py
Lines:  334
Doc:    Static execution viability analysis.
Deps:   __future__, typing
  Functions (2):
    analyze_static_viability() (line 52): Analyze a structural scan result for execution viability.
    triage_batch() (line 292): Run static analysis on all repos and return summary.

------------------------------------------------------------------------------
Module: stratum_lab\validation\__init__.py
Lines:  1
Doc:    Node ID compatibility validation between structural scan and behavioral patcher.

------------------------------------------------------------------------------
Module: stratum_lab\validation\id_checker.py
Lines:  59
Doc:    Compare node IDs produced by stratum-cli structural scan vs. stratum-patcher instrumentation.
Deps:   json, pathlib, typing
  Functions (3):
    load_structural_ids() (line 20): Extract node IDs from a stratum-cli structural graph JSON.
    load_event_ids() (line 28): Extract unique source_node_id values from JSONL event files.
    compare_ids() (line 42): Compare two sets of node IDs and report compatibility.

------------------------------------------------------------------------------
Module: stratum_patcher\__init__.py
Lines:  41
Doc:    Stratum Patcher — import-time monkey-patching for AI agent frameworks.
Deps:   __future__, stratum_patcher

------------------------------------------------------------------------------
Module: stratum_patcher\anthropic_patch.py
Lines:  523
Doc:    Monkey-patch for the Anthropic Python client.
Deps:   __future__, anthropic, functools, json, openai, os, stratum_patcher, time, typing
  Classes (1):
    class _Ns (line 176): Tiny attribute namespace.
  Functions (4):
    remap_model() (line 42): Remap any model name to the vLLM-served model when STRATUM_VLLM_MODEL is set.
    patch() (line 477): Apply monkey-patches to the anthropic module.  Idempotent.
    wrapper() (line 391): (no docstring)
    wrapper() (line 434): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\autogen_patch.py
Lines:  619
Doc:    Monkey-patch for Microsoft AutoGen (pyautogen / autogen-agentchat).
Deps:   __future__, functools, stratum_patcher, time, typing
  Functions (7):
    patch() (line 492): Apply monkey-patches to AutoGen internals.  Idempotent.
    wrapper() (line 39): (no docstring)
    wrapper() (line 111): (no docstring)
    wrapper() (line 182): (no docstring)
    wrapper() (line 260): (no docstring)
    wrapper() (line 334): (no docstring)
    wrapper() (line 390): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\crewai_patch.py
Lines:  516
Doc:    Monkey-patch for crewAI internals.
Deps:   __future__, crewai, functools, langchain_core, stratum_patcher, time, traceback, typing
  Functions (7):
    patch() (line 408): Apply monkey-patches to crewAI internals.  Idempotent.
    wrapper() (line 42): (no docstring)
    wrapper() (line 111): (no docstring)
    wrapper() (line 212): (no docstring)
    wrapper() (line 267): (no docstring)
    patched_run() (line 360): (no docstring)
    delegate_run() (line 473): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\event_logger.py
Lines:  332
Doc:    JSONL event writer for stratum-patcher.
Deps:   __future__, hashlib, inspect, json, os, threading, time, typing, uuid
  Classes (1):
    class EventLogger (line 171): Append-only JSONL event writer.  Singleton — use ``EventLogger.get()``.
      .get() (line 200): Return the global singleton, creating it on first call.
      .run_id() (line 211): (no docstring)
      .repo_id() (line 215): (no docstring)
      .framework() (line 219): (no docstring)
      .log_event() (line 222): Write one JSON-line event.  Returns the generated ``event_id``.
      .push_active_node() (line 267): Called when a node (agent) begins execution.
      .pop_active_node() (line 271): Called when a node (agent) finishes execution.
      .current_node() (line 277): Return the currently-executing node ID.
      .parent_node() (line 281): Return the parent (calling) node, or empty string.
      .record_edge_activation() (line 285): Record that an edge was activated (delegation or data flow).
      .record_error_context() (line 295): Record error with causal context for propagation tracing.
  Functions (18):
    make_node() (line 24): Return a node descriptor dict suitable for event source/target fields.
    generate_node_id() (line 29): Return a runtime node ID: ``framework:ClassName:file:line``.
    get_caller_info() (line 39): Inspect the call stack and return ``(filename, lineno, func_name)``.
    hash_content() (line 59): Return a hex SHA-256 digest of *content* (stringified first).
    get_data_shape() (line 68): Return a short string describing the *shape/type* of *obj*.
    capture_output_signature() (line 107): Capture a lightweight semantic signature of agent/LLM output.
    classify_error() (line 309): Classify an error into behavioral categories.
    get() (line 200): Return the global singleton, creating it on first call.
    run_id() (line 211): (no docstring)
    repo_id() (line 215): (no docstring)
    framework() (line 219): (no docstring)
    log_event() (line 222): Write one JSON-line event.  Returns the generated ``event_id``.
    push_active_node() (line 267): Called when a node (agent) begins execution.
    pop_active_node() (line 271): Called when a node (agent) finishes execution.
    current_node() (line 277): Return the currently-executing node ID.
    parent_node() (line 281): Return the parent (calling) node, or empty string.
    record_edge_activation() (line 285): Record that an edge was activated (delegation or data flow).
    record_error_context() (line 295): Record error with causal context for propagation tracing.

------------------------------------------------------------------------------
Module: stratum_patcher\generic_patch.py
Lines:  477
Doc:    Generic patches that apply regardless of AI framework.
Deps:   __future__, builtins, functools, httpx, os, requests, stratum_patcher, sys, time, traceback, typing, urllib
  Functions (6):
    patch() (line 341): Apply generic monkey-patches.  Idempotent.
    wrapper() (line 67): (no docstring)
    wrapper() (line 127): (no docstring)
    wrapper() (line 185): (no docstring)
    wrapper() (line 250): (no docstring)
    wrapper() (line 295): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\langchain_patch.py
Lines:  236
Doc:    LangChain chain instrumentation for stratum-patcher.
Deps:   __future__, functools, langchain, langchain_core, stratum_patcher, time, typing
  Functions (2):
    patch_langchain() (line 28): Monkey-patch LangChain Chain.invoke and BaseChatModel._generate.
    patch() (line 230): Apply LangChain patches. Alias for patch_langchain().

------------------------------------------------------------------------------
Module: stratum_patcher\langgraph_patch.py
Lines:  569
Doc:    Monkey-patch for LangGraph.
Deps:   __future__, functools, langgraph, stratum_patcher, time, typing
  Functions (10):
    patch() (line 471): Apply monkey-patches to langgraph internals.  Idempotent.
    wrapper() (line 40): (no docstring)
    wrapper() (line 112): (no docstring)
    wrapper() (line 191): (no docstring)
    wrapper() (line 249): (no docstring)
    wrapper() (line 330): (no docstring)
    wrapper() (line 388): (no docstring)
    wrapper() (line 412): (no docstring)
    instrumented_action() (line 254): (no docstring)
    instrumented_path() (line 342): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\openai_patch.py
Lines:  509
Doc:    Monkey-patch for the OpenAI Python client.
Deps:   __future__, functools, hashlib, json, openai, os, stratum_patcher, time, typing
  Functions (4):
    remap_model() (line 39): Remap any model name to the vLLM-served model when STRATUM_VLLM_MODEL is set.
    patch() (line 421): Apply monkey-patches to the openai module.  Idempotent.
    wrapper() (line 168): (no docstring)
    wrapper() (line 309): (no docstring)

------------------------------------------------------------------------------
Module: stratum_patcher\runner.py
Lines:  250
Doc:    Stratum runner — entry-point wrapper for instrumented execution.
Deps:   __future__, importlib, os, pathlib, re, runpy, signal, stratum_patcher, sys, threading, time, traceback, typing
  Functions (2):
    detect_frameworks_in_source() (line 38): Scan .py files for import patterns including lazy imports.
    main() (line 104): Run the target entry point with stratum instrumentation active.

------------------------------------------------------------------------------
Module: stratum_patcher\sitecustomize.py
Lines:  12
Doc:    Auto-load stratum patcher at Python startup.
Deps:   stratum_patcher

------------------------------------------------------------------------------
Module: tests\__init__.py
Lines:  0

------------------------------------------------------------------------------
Module: tests\conftest.py
Lines:  243
Deps:   collections, pytest
  Functions (3):
    sample_structural_graph() (line 5): A 4-agent crewAI system with tools, data stores, external services, and guardrails.
    sample_events() (line 43): Generate events for 3 runs covering all event types.
    sample_run_records() (line 227): Build run records from sample events, with events attached.

------------------------------------------------------------------------------
Module: tests\test_fingerprint.py
Lines:  409
Doc:    Tests for graph fingerprinting.
Deps:   pytest, stratum_lab
  Classes (3):
    class TestComputeGraphFingerprint (line 202): Tests for compute_graph_fingerprint.
      .test_returns_feature_vector_of_length_20() (line 205): The fingerprint must contain a feature_vector list of exactly 20 floats.
      .test_returns_expected_top_level_keys() (line 215): The fingerprint dict must have the documented top-level keys.
      .test_deterministic_same_graph() (line 229): Calling compute_graph_fingerprint twice on the same graph must
      .test_different_graphs_produce_different_fingerprints() (line 240): Two structurally different graphs must produce different
      .test_structural_metrics_counts_match_graph() (line 252): Structural metrics should reflect the actual node/edge counts.
      .test_motifs_detected() (line 264): The sample graph should trigger at least the
      .test_topology_hash_is_hex_sha256() (line 274): topology_hash must be a valid 64-character hex string (SHA-256).
    class TestNormalizeFeatureVector (line 289): Tests for normalize_feature_vector.
      .test_normalized_values_in_0_1() (line 292): Every element of the normalized vector must be in [0, 1].
      .test_zero_range_maps_to_zero() (line 308): When min == max for a feature, the normalized value should be 0.0.
      .test_exact_min_maps_to_zero() (line 318): A value equal to the minimum should normalize to 0.0.
      .test_exact_max_maps_to_one() (line 328): A value equal to the maximum should normalize to 1.0.
      .test_values_clamped_above_max() (line 338): Values above max should be clamped to 1.0.
      .test_values_clamped_below_min() (line 348): Values below min should be clamped to 0.0.
    class TestComputeNormalizationConstants (line 363): Tests for compute_normalization_constants.
      .test_returns_min_max_for_each_feature() (line 366): The result should have an entry for each of the 20 feature indices,
      .test_single_fingerprint_min_equals_max() (line 382): With only one fingerprint, min and max should be equal for every feature.
      .test_empty_list_returns_empty_dict() (line 391): An empty list of fingerprints should return empty min/max lists.
      .test_min_max_reflect_actual_extremes() (line 396): The min/max should reflect the actual minimum and maximum values
  Functions (19):
    sample_structural_graph() (line 15): A representative structural graph with 10 nodes and 10 edges.
    minimal_graph() (line 165): A minimal graph with 2 agents and 1 edge -- structurally distinct
    test_returns_feature_vector_of_length_20() (line 205): The fingerprint must contain a feature_vector list of exactly 20 floats.
    test_returns_expected_top_level_keys() (line 215): The fingerprint dict must have the documented top-level keys.
    test_deterministic_same_graph() (line 229): Calling compute_graph_fingerprint twice on the same graph must
    test_different_graphs_produce_different_fingerprints() (line 240): Two structurally different graphs must produce different
    test_structural_metrics_counts_match_graph() (line 252): Structural metrics should reflect the actual node/edge counts.
    test_motifs_detected() (line 264): The sample graph should trigger at least the
    test_topology_hash_is_hex_sha256() (line 274): topology_hash must be a valid 64-character hex string (SHA-256).
    test_normalized_values_in_0_1() (line 292): Every element of the normalized vector must be in [0, 1].
    test_zero_range_maps_to_zero() (line 308): When min == max for a feature, the normalized value should be 0.0.
    test_exact_min_maps_to_zero() (line 318): A value equal to the minimum should normalize to 0.0.
    test_exact_max_maps_to_one() (line 328): A value equal to the maximum should normalize to 1.0.
    test_values_clamped_above_max() (line 338): Values above max should be clamped to 1.0.
    test_values_clamped_below_min() (line 348): Values below min should be clamped to 0.0.
    test_returns_min_max_for_each_feature() (line 366): The result should have an entry for each of the 20 feature indices,
    test_single_fingerprint_min_equals_max() (line 382): With only one fingerprint, min and max should be equal for every feature.
    test_empty_list_returns_empty_dict() (line 391): An empty list of fingerprints should return empty min/max lists.
    test_min_max_reflect_actual_extremes() (line 396): The min/max should reflect the actual minimum and maximum values

------------------------------------------------------------------------------
Module: tests\test_overlay.py
Lines:  310
Doc:    Tests validating overlay bug fixes from Part 1 and Part 2 features.
Deps:   pytest, stratum_lab
  Classes (14):
    class TestCapabilityNodesGetBehavioralData (line 8): Bug fix 1A: capability nodes should have non-zero behavioral data.
      .test_capability_node_activation_count() (line 11): (no docstring)
      .test_capability_node_llm() (line 16): (no docstring)
    class TestDataStoreNodesGetBehavioralData (line 22): Bug fix 1A: data store nodes should have non-zero data.
      .test_data_store_activation() (line 25): (no docstring)
    class TestExternalServiceNodesGetData (line 31): (no docstring)
      .test_external_node_activation() (line 32): (no docstring)
    class TestGuardrailNodesGetData (line 38): (no docstring)
      .test_guardrail_activation() (line 39): (no docstring)
      .test_guardrail_effectiveness() (line 44): (no docstring)
    class TestActivationRateIs0To1 (line 52): Bug fix 1C: activation_rate should be 0.0-1.0.
      .test_node_activation_rate_range() (line 55): (no docstring)
      .test_edge_activation_rate_range() (line 61): (no docstring)
    class TestDecisionBehaviorPopulated (line 68): Bug fix 1D: decision_behavior should be populated for nodes with decision.made events.
      .test_decision_behavior_not_none() (line 71): (no docstring)
    class TestStructuralPredictionMatch (line 79): Bug fix 1E: structural_prediction_match should be populated.
      .test_prediction_match_on_error_node() (line 82): (no docstring)
    class TestErrorPropagationThroughEdges (line 90): Bug fix 1F: error propagation should update edge error_crossings.
      .test_at_least_one_edge_has_error_crossings() (line 93): (no docstring)
    class TestEdgeTraversalCounts (line 103): Bug fix 1B: edges should have non-zero traversal when events reference them.
      .test_delegation_edges_traversed() (line 106): (no docstring)
      .test_uses_edges_traversed() (line 111): (no docstring)
    class TestUnmappedEventsZero (line 117): All event types exercised should result in 0 unmapped events.
      .test_unmapped_node_events_zero() (line 120): (no docstring)
    class TestDeterminismMetrics (line 130): Part 2A: determinism metrics should be present on enriched nodes.
      .test_determinism_present_on_active_nodes() (line 133): (no docstring)
      .test_same_input_consistency_high_for_identical_runs() (line 142): Runs 000 and 001 use same input_hash and have identical events, so consistency should be 1.0.
      .test_same_input_path_consistency_high() (line 149): Same-input runs have identical activation counts, so path consistency should be 1.0.
      .test_cross_input_variance_low_for_uniform_behavior() (line 156): All runs activate the same nodes equally, so cross-input variance should be low.
      .test_determinism_none_for_single_run() (line 163): With only 1 run, determinism should be None.
    class TestExecutionPaths (line 185): Part 2B: execution paths and path analysis should be present.
      .test_execution_paths_present() (line 188): (no docstring)
      .test_execution_path_has_run_id() (line 193): (no docstring)
      .test_execution_path_steps_have_edge_fields() (line 199): (no docstring)
      .test_execution_paths_non_empty_for_edge_events() (line 209): Runs with delegation/tool/data events should produce non-empty execution paths.
    class TestPathAnalysis (line 216): Part 2B: path analysis aggregate should be computed.
      .test_path_analysis_present() (line 219): (no docstring)
      .test_distinct_paths_at_least_one() (line 228): (no docstring)
      .test_dominant_path_frequency_in_range() (line 233): (no docstring)
    class TestFailureImpact (line 243): Part 2C: failure_impact should appear on capability nodes with failures.
      .test_no_failure_impact_when_no_failures() (line 246): Sample events have no tool failures, so failure_impact should not be present.
      .test_failure_impact_present_when_failures_exist() (line 253): Build events with tool failures and verify failure_impact is populated.
  Functions (28):
    test_capability_node_activation_count() (line 11): (no docstring)
    test_capability_node_llm() (line 16): (no docstring)
    test_data_store_activation() (line 25): (no docstring)
    test_external_node_activation() (line 32): (no docstring)
    test_guardrail_activation() (line 39): (no docstring)
    test_guardrail_effectiveness() (line 44): (no docstring)
    test_node_activation_rate_range() (line 55): (no docstring)
    test_edge_activation_rate_range() (line 61): (no docstring)
    test_decision_behavior_not_none() (line 71): (no docstring)
    test_prediction_match_on_error_node() (line 82): (no docstring)
    test_at_least_one_edge_has_error_crossings() (line 93): (no docstring)
    test_delegation_edges_traversed() (line 106): (no docstring)
    test_uses_edges_traversed() (line 111): (no docstring)
    test_unmapped_node_events_zero() (line 120): (no docstring)
    test_determinism_present_on_active_nodes() (line 133): (no docstring)
    test_same_input_consistency_high_for_identical_runs() (line 142): Runs 000 and 001 use same input_hash and have identical events, so consistency should be 1.0.
    test_same_input_path_consistency_high() (line 149): Same-input runs have identical activation counts, so path consistency should be 1.0.
    test_cross_input_variance_low_for_uniform_behavior() (line 156): All runs activate the same nodes equally, so cross-input variance should be low.
    test_determinism_none_for_single_run() (line 163): With only 1 run, determinism should be None.
    test_execution_paths_present() (line 188): (no docstring)
    test_execution_path_has_run_id() (line 193): (no docstring)
    test_execution_path_steps_have_edge_fields() (line 199): (no docstring)
    test_execution_paths_non_empty_for_edge_events() (line 209): Runs with delegation/tool/data events should produce non-empty execution paths.
    test_path_analysis_present() (line 219): (no docstring)
    test_distinct_paths_at_least_one() (line 228): (no docstring)
    test_dominant_path_frequency_in_range() (line 233): (no docstring)
    test_no_failure_impact_when_no_failures() (line 246): Sample events have no tool failures, so failure_impact should not be present.
    test_failure_impact_present_when_failures_exist() (line 253): Build events with tool failures and verify failure_impact is populated.

------------------------------------------------------------------------------
Module: tests\test_patchers.py
Lines:  1240
Doc:    Unit tests for stratum_patcher monkey-patching modules.
Deps:   __future__, asyncio, builtins, collections, importlib, json, openai, os, pathlib, pytest, requests, stratum_patcher, sys, tempfile, types, unittest
  Classes (41):
    class TestEventLogger (line 83): Tests for the EventLogger singleton and log_event method.
      .setup_method() (line 86): (no docstring)
      .teardown_method() (line 94): (no docstring)
      .test_singleton_identity() (line 104): (no docstring)
      .test_log_event_returns_event_id() (line 110): (no docstring)
      .test_log_event_writes_valid_jsonl() (line 115): (no docstring)
      .test_log_event_with_all_optional_fields() (line 125): (no docstring)
      .test_run_id_and_repo_id_from_env() (line 157): (no docstring)
      .test_generate_node_id() (line 168): (no docstring)
      .test_make_node() (line 173): (no docstring)
      .test_hash_content() (line 178): (no docstring)
      .test_get_data_shape() (line 187): (no docstring)
      .test_capture_output_signature_none() (line 195): (no docstring)
      .test_capture_output_signature_string() (line 202): (no docstring)
      .test_capture_output_signature_long_text() (line 211): (no docstring)
      .test_capture_output_signature_classification() (line 217): (no docstring)
      .test_capture_output_signature_routing() (line 225): (no docstring)
      .test_capture_output_signature_scored() (line 233): (no docstring)
      .test_capture_output_signature_structured_json() (line 239): (no docstring)
    class TestOpenAIPatch (line 253): Test that openai_patch wraps the modern completions API correctly.
      .setup_method() (line 256): (no docstring)
      .teardown_method() (line 264): (no docstring)
      .test_openai_patch_wraps_create() (line 335): (no docstring)
      .test_openai_patch_emits_events() (line 349): (no docstring)
      .test_openai_patch_semantic_fields() (line 380): Verify llm.call_end contains semantic capture fields.
      .test_openai_patch_parent_event_chain() (line 401): (no docstring)
    class TestGenericPatch (line 426): Test generic_patch: requests wrapping and builtins.open wrapping.
      .setup_method() (line 429): (no docstring)
      .teardown_method() (line 437): (no docstring)
      .test_generic_patch_module_loads() (line 447): Verify the generic_patch module can be imported without error.
      .test_requests_wrapping() (line 453): Verify that requests.get/post get wrapped if requests is available.
      .test_builtins_open_wrapping() (line 469): Verify that builtins.open is wrapped.
      .test_excepthook_wrapping() (line 476): Verify that sys.excepthook is wrapped.
      .test_file_open_under_app_emits_event() (line 483): Opening a file under /app/ should emit a file.read or file.write event.
      .test_domain_extraction() (line 499): Test the _domain_only helper.
    class TestCrewAIPatch (line 510): Test crewai_patch: verify patch() is callable and module loads cleanly.
      .setup_method() (line 513): (no docstring)
      .teardown_method() (line 521): (no docstring)
      .test_crewai_patch_loads() (line 531): (no docstring)
      .test_crewai_wrapper_functions_exist() (line 537): (no docstring)
      .test_crewai_kickoff_wrapper_emits_events() (line 544): Simulate what the wrapper does without needing actual crewai.
    class TestLangGraphPatch (line 576): Test langgraph_patch module.
      .setup_method() (line 579): (no docstring)
      .teardown_method() (line 587): (no docstring)
      .test_langgraph_patch_loads() (line 597): (no docstring)
      .test_langgraph_wrapper_functions_exist() (line 603): (no docstring)
      .test_langgraph_invoke_wrapper_emits_events() (line 611): Simulate what the invoke wrapper does.
    class TestAutoGenPatch (line 640): Test autogen_patch module.
      .setup_method() (line 643): (no docstring)
      .teardown_method() (line 651): (no docstring)
      .test_autogen_patch_loads() (line 661): (no docstring)
      .test_autogen_wrapper_functions_exist() (line 667): (no docstring)
      .test_autogen_receive_wrapper_emits_events() (line 674): Simulate what the receive wrapper does.
    class TestAnthropicPatch (line 711): Test anthropic_patch module.
      .setup_method() (line 714): (no docstring)
      .teardown_method() (line 722): (no docstring)
      .test_anthropic_patch_loads() (line 732): (no docstring)
      .test_translate_messages_basic() (line 737): Test the Anthropic->OpenAI message translation.
      .test_translate_messages_with_tool_use() (line 755): Test tool_use content block translation.
      .test_translate_tools() (line 781): Test Anthropic tool definition -> OpenAI tool format.
      .test_translate_response_to_anthropic() (line 801): Test OpenAI response -> Anthropic response translation.
    class TestCrossPatcherIntegration (line 837): Test that multiple patchers can coexist and all write to the same JSONL.
      .setup_method() (line 840): (no docstring)
      .teardown_method() (line 848): (no docstring)
      .test_multiple_event_types_in_single_file() (line 858): Log events from different conceptual patchers to the same file.
    class TestAsyncOpenAIPatch (line 900): Test that openai_patch wraps the async completions API correctly.
      .setup_method() (line 903): (no docstring)
      .teardown_method() (line 911): (no docstring)
      .test_async_openai_patch() (line 924): Verify AsyncCompletions.create gets _stratum_patched and emits events.
    class TestLangChainChainPatch (line 1018): Test langchain_patch: Chain.invoke emits agent.task_start/end.
      .setup_method() (line 1021): (no docstring)
      .teardown_method() (line 1029): (no docstring)
      .test_langchain_chain_invoke() (line 1043): Mock langchain Chain.invoke and verify agent.task_start/end emitted.
    class TestLangChainChatModelPatch (line 1097): Test langchain_patch: BaseChatModel._generate emits llm.call_start/end.
      .setup_method() (line 1100): (no docstring)
      .teardown_method() (line 1108): (no docstring)
      .test_langchain_chat_model_generate() (line 1121): Mock BaseChatModel._generate and verify llm.call_start/end emitted.
    class TestBareHTTPOpenAIPatch (line 1191): Test that requests.post to api.openai.com emits llm.call_start/end.
      .setup_method() (line 1194): (no docstring)
      .teardown_method() (line 1202): (no docstring)
      .test_bare_http_openai_detection() (line 1212): Verify LLM_API_PATTERNS constant exists in generic_patch.
      .test_bare_http_openai_emits_events() (line 1218): Mock requests.post to api.openai.com and verify events emitted.
    class MockMessage (line 281): (no docstring)
    class MockChoice (line 286): (no docstring)
    class MockUsage (line 291): (no docstring)
    class MockResponse (line 296): (no docstring)
    class Completions (line 302): (no docstring)
      .create() (line 304): (no docstring)
    class AsyncCompletions (line 307): (no docstring)
      .create() (line 309): (no docstring)
    class Chat (line 312): (no docstring)
    class OpenAI (line 315): (no docstring)
    class FakeCrew (line 549): (no docstring)
      .kickoff() (line 555): (no docstring)
    class FakeGraph (line 615): (no docstring)
      .invoke() (line 619): (no docstring)
    class FakeAgent (line 678): (no docstring)
      .receive() (line 681): (no docstring)
    class FakeSender (line 684): (no docstring)
    class MockMsg (line 805): (no docstring)
    class MockChoice (line 809): (no docstring)
    class MockUsage (line 813): (no docstring)
    class MockResp (line 817): (no docstring)
    class MockMessage (line 928): (no docstring)
    class MockChoice (line 933): (no docstring)
    class MockUsage (line 938): (no docstring)
    class MockResponse (line 943): (no docstring)
    class Completions (line 949): (no docstring)
      .create() (line 951): (no docstring)
    class AsyncCompletions (line 954): (no docstring)
      .create() (line 956): (no docstring)
    class Chat (line 959): (no docstring)
    class OpenAI (line 962): (no docstring)
    class AsyncOpenAI (line 965): (no docstring)
    class MockChain (line 1047): (no docstring)
      .invoke() (line 1048): (no docstring)
      .ainvoke() (line 1051): (no docstring)
    class MockChatResult (line 1124): (no docstring)
    class MockBaseChatModel (line 1127): (no docstring)
    class MockChain (line 1147): (no docstring)
      .invoke() (line 1148): (no docstring)
  Functions (80):
    setup_method() (line 86): (no docstring)
    teardown_method() (line 94): (no docstring)
    test_singleton_identity() (line 104): (no docstring)
    test_log_event_returns_event_id() (line 110): (no docstring)
    test_log_event_writes_valid_jsonl() (line 115): (no docstring)
    test_log_event_with_all_optional_fields() (line 125): (no docstring)
    test_run_id_and_repo_id_from_env() (line 157): (no docstring)
    test_generate_node_id() (line 168): (no docstring)
    test_make_node() (line 173): (no docstring)
    test_hash_content() (line 178): (no docstring)
    test_get_data_shape() (line 187): (no docstring)
    test_capture_output_signature_none() (line 195): (no docstring)
    test_capture_output_signature_string() (line 202): (no docstring)
    test_capture_output_signature_long_text() (line 211): (no docstring)
    test_capture_output_signature_classification() (line 217): (no docstring)
    test_capture_output_signature_routing() (line 225): (no docstring)
    test_capture_output_signature_scored() (line 233): (no docstring)
    test_capture_output_signature_structured_json() (line 239): (no docstring)
    setup_method() (line 256): (no docstring)
    teardown_method() (line 264): (no docstring)
    test_openai_patch_wraps_create() (line 335): (no docstring)
    test_openai_patch_emits_events() (line 349): (no docstring)
    test_openai_patch_semantic_fields() (line 380): Verify llm.call_end contains semantic capture fields.
    test_openai_patch_parent_event_chain() (line 401): (no docstring)
    setup_method() (line 429): (no docstring)
    teardown_method() (line 437): (no docstring)
    test_generic_patch_module_loads() (line 447): Verify the generic_patch module can be imported without error.
    test_requests_wrapping() (line 453): Verify that requests.get/post get wrapped if requests is available.
    test_builtins_open_wrapping() (line 469): Verify that builtins.open is wrapped.
    test_excepthook_wrapping() (line 476): Verify that sys.excepthook is wrapped.
    test_file_open_under_app_emits_event() (line 483): Opening a file under /app/ should emit a file.read or file.write event.
    test_domain_extraction() (line 499): Test the _domain_only helper.
    setup_method() (line 513): (no docstring)
    teardown_method() (line 521): (no docstring)
    test_crewai_patch_loads() (line 531): (no docstring)
    test_crewai_wrapper_functions_exist() (line 537): (no docstring)
    test_crewai_kickoff_wrapper_emits_events() (line 544): Simulate what the wrapper does without needing actual crewai.
    setup_method() (line 579): (no docstring)
    teardown_method() (line 587): (no docstring)
    test_langgraph_patch_loads() (line 597): (no docstring)
    test_langgraph_wrapper_functions_exist() (line 603): (no docstring)
    test_langgraph_invoke_wrapper_emits_events() (line 611): Simulate what the invoke wrapper does.
    setup_method() (line 643): (no docstring)
    teardown_method() (line 651): (no docstring)
    test_autogen_patch_loads() (line 661): (no docstring)
    test_autogen_wrapper_functions_exist() (line 667): (no docstring)
    test_autogen_receive_wrapper_emits_events() (line 674): Simulate what the receive wrapper does.
    setup_method() (line 714): (no docstring)
    teardown_method() (line 722): (no docstring)
    test_anthropic_patch_loads() (line 732): (no docstring)
    test_translate_messages_basic() (line 737): Test the Anthropic->OpenAI message translation.
    test_translate_messages_with_tool_use() (line 755): Test tool_use content block translation.
    test_translate_tools() (line 781): Test Anthropic tool definition -> OpenAI tool format.
    test_translate_response_to_anthropic() (line 801): Test OpenAI response -> Anthropic response translation.
    setup_method() (line 840): (no docstring)
    teardown_method() (line 848): (no docstring)
    test_multiple_event_types_in_single_file() (line 858): Log events from different conceptual patchers to the same file.
    setup_method() (line 903): (no docstring)
    teardown_method() (line 911): (no docstring)
    test_async_openai_patch() (line 924): Verify AsyncCompletions.create gets _stratum_patched and emits events.
    setup_method() (line 1021): (no docstring)
    teardown_method() (line 1029): (no docstring)
    test_langchain_chain_invoke() (line 1043): Mock langchain Chain.invoke and verify agent.task_start/end emitted.
    setup_method() (line 1100): (no docstring)
    teardown_method() (line 1108): (no docstring)
    test_langchain_chat_model_generate() (line 1121): Mock BaseChatModel._generate and verify llm.call_start/end emitted.
    setup_method() (line 1194): (no docstring)
    teardown_method() (line 1202): (no docstring)
    test_bare_http_openai_detection() (line 1212): Verify LLM_API_PATTERNS constant exists in generic_patch.
    test_bare_http_openai_emits_events() (line 1218): Mock requests.post to api.openai.com and verify events emitted.
    create() (line 304): (no docstring)
    create() (line 309): (no docstring)
    kickoff() (line 555): (no docstring)
    invoke() (line 619): (no docstring)
    receive() (line 681): (no docstring)
    create() (line 951): (no docstring)
    create() (line 956): (no docstring)
    invoke() (line 1048): (no docstring)
    ainvoke() (line 1051): (no docstring)
    invoke() (line 1148): (no docstring)

------------------------------------------------------------------------------
Module: tests\test_query.py
Lines:  777
Doc:    Tests for the product query layer (Part 3).
Deps:   json, pathlib, pytest, stratum_lab, tempfile
  Classes (4):
    class TestMatchAgainstDataset (line 463): Tests for match_against_dataset.
      .test_match_returns_motif_matches() (line 466): A graph containing the shared_state_without_arbitration motif
      .test_match_returns_similarity_matches() (line 484): Structural similarity matches should be present and ranked in
      .test_match_returns_list_of_match_objects() (line 500): All returned items should be Match dataclass instances.
      .test_match_overall_sorted_by_score() (line 511): The full match list should be sorted by similarity_score descending.
    class TestPredictRisks (line 523): Tests for predict_risks.
      .test_predict_risks_non_empty() (line 526): predict_risks should return at least 1 predicted risk when the
      .test_predict_overall_risk_score_in_range() (line 541): The overall_risk_score must be in the range [0, 100].
      .test_predict_returns_risk_prediction_dataclass() (line 553): The return value must be a RiskPrediction dataclass with the
      .test_predict_risks_have_remediation() (line 571): Each predicted risk that has KB data should carry a non-empty
      .test_predict_positive_signals_for_guardrail() (line 589): The sample graph has a guardrail node, so positive signals should
      .test_predict_dataset_coverage() (line 606): dataset_coverage should report on preconditions queried vs. found.
    class TestGenerateRiskReport (line 627): Tests for generate_risk_report.
      .test_report_json_valid() (line 640): generate_risk_report with format='json' should return a dict
      .test_report_markdown_valid() (line 673): generate_risk_report with format='markdown' should return a
      .test_report_markdown_contains_risk_info() (line 689): The markdown report should contain information about the predicted
      .test_report_json_risk_details_match_prediction() (line 701): The number of risk_details entries in the JSON report should equal
    class TestEndToEndQueryFlow (line 719): End-to-end: synthetic structural graph -> fingerprint -> match ->
      .test_end_to_end_query_flow() (line 724): Run the full query pipeline and verify that each stage produces
  Functions (17):
    synthetic_kb() (line 18): Create a temporary knowledge-base directory populated with the JSON
    sample_structural_graph() (line 297): A structural graph that triggers the shared_state_without_arbitration
    test_match_returns_motif_matches() (line 466): A graph containing the shared_state_without_arbitration motif
    test_match_returns_similarity_matches() (line 484): Structural similarity matches should be present and ranked in
    test_match_returns_list_of_match_objects() (line 500): All returned items should be Match dataclass instances.
    test_match_overall_sorted_by_score() (line 511): The full match list should be sorted by similarity_score descending.
    test_predict_risks_non_empty() (line 526): predict_risks should return at least 1 predicted risk when the
    test_predict_overall_risk_score_in_range() (line 541): The overall_risk_score must be in the range [0, 100].
    test_predict_returns_risk_prediction_dataclass() (line 553): The return value must be a RiskPrediction dataclass with the
    test_predict_risks_have_remediation() (line 571): Each predicted risk that has KB data should carry a non-empty
    test_predict_positive_signals_for_guardrail() (line 589): The sample graph has a guardrail node, so positive signals should
    test_predict_dataset_coverage() (line 606): dataset_coverage should report on preconditions queried vs. found.
    test_report_json_valid() (line 640): generate_risk_report with format='json' should return a dict
    test_report_markdown_valid() (line 673): generate_risk_report with format='markdown' should return a
    test_report_markdown_contains_risk_info() (line 689): The markdown report should contain information about the predicted
    test_report_json_risk_details_match_prediction() (line 701): The number of risk_details entries in the JSON report should equal
    test_end_to_end_query_flow() (line 724): Run the full query pipeline and verify that each stage produces

==============================================================================
TOTALS
==============================================================================
  Modules:    83
  Lines:      28969
  Functions:  393 (public only)
  Classes:    86
